<?php

/**
 * Instagram Basic Display API
 *
 * #pw-var $instagram
 * #pw-order-groups media, profile, instagram-feed, authentication
 * #pw-summary Instagram Basic Display API is an HTTP-based API that apps can use to get an Instagram user's profile, images, videos, and albums.
 * #pw-summary-instagram-feed These methods provide some backwards compatibility with Instagram Feed (https://modules.processwire.com/modules/instagram-feed/).
 * #pw-body =
 * More information here: https://developers.facebook.com/docs/instagram-basic-display-api/
 * #pw-body
 *
 * @copyright 2020 NB Communication Ltd
 * @license Mozilla Public License v2.0 http://mozilla.org/MPL/2.0/
 *
 */

class InstagramBasicDisplayApi extends WireData implements Module, ConfigurableModule {

	/**
	 * getModuleInfo is a module required by all modules to tell ProcessWire about them
	 *
	 * @return array
	 *
	 */
	public static function getModuleInfo() {

		return [
			"title" => "Instagram Basic Display API",
			"version" => 101,
			"summary" => "Instagram Basic Display API is an HTTP-based API that apps can use to get an Instagram user's profile, images, videos, and albums.",
			"author" => "chriswthomson",
			"href" => "https://github.com/nbcommunication/InstagramBasicDisplayApi",
			"autoload" => "template=admin",
			"singular" => true,
			"icon" => "instagram",
		];
	}

	/**
	 * For getting Instagram User Access Tokens
	 *
	 * @var string
	 *
	 */
	const urlAccess = "https://api.instagram.com/";

	/**
	 * For getting Instagram User Access Tokens
	 *
	 * @var string
	 *
	 */
	const urlGraph = "https://graph.instagram.com/";

	/**
	 * Media Types
	 *
	 * @var string
	 *
	 */
	const mediaTypes = [
		"carouselAlbum" => "CAROUSEL_ALBUM",
		"image" => "IMAGE",
		"video" => "VIDEO",
	];

	/**
	 * The number of images to be returned
	 *
	 * @var int
	 *
	 */
	protected $imageCount = 4;

	/**
	 * Initialize the module
	 *
	 */
	public function init() {
		// Do Nothing
	}

	/**
	 * Initialize the module
	 *
	 */
	public function ready() {
		// Hook before the admin controller
		if(!$this->wire("config")->ajax) {
			// No need to hook on AJAX requests
			$this->addHookBefore("ProcessController::execute", function(HookEvent $event) {
				// If this is a response from Instagram, process it
				if($event->wire("input")->urlSegment1 == $this->className) {
					$this->processResponse();
				}
			});
		}
	}

	/**
	 * Get the Authorization Code URI
	 *
	 * https://developers.facebook.com/docs/instagram-basic-display-api/reference/oauth-authorize
	 * 
	 * #pw-group-authentication
	 *
	 * @return string
	 *
	 */
	public function getAuthUri() {
		return self::urlAccess . "oauth/authorize?" . http_build_query([
			"client_id" => $this->clientId,
			"redirect_uri" => $this->getRedirectUri(),
			"scope" => "user_media,user_profile",
			"response_type" => "code",
			"state" => $this->getState(),
		]);
	}

	/**
	 * Get the most recent Carousel Album for a user
	 * 
	 * ~~~
	 * // Get the most recent album from the default user
	 * $album = $instagram->getCarouselAlbum();
	 * // Get the most recent album from a specified user
	 * $album = $instagram->getCarouselAlbum("username");
	 * // Render the album
	 * if(isset($album)) {
	 *     echo "<ul>" . $album->children->each("<li><a href='{href}'><img src='{src}' alt='{alt}'></a></li>") . "</ul>";
	 * }
	 * ~~~
	 * 
	 * #pw-group-media
	 *
	 * @param string $username The username of the authorized Instagram user.
	 * @return WireData|null
	 * @see InstagramBasicDisplayApi::getMedia()
	 *
	 */
	public function getCarouselAlbum($username = null) {
		$album = $this->getCarouselAlbums($username, 1);
		return $album->count() ? $album->first : null;
	}

	/**
	 * Get a list of Carousel Albums for a user
	 * 
	 * ~~~
	 * // Get albums from the default user 
	 * $albums = $instagram->getCarouselAlbums(); // 4 returned if found
	 * // Get 2 albums from the default user
	 * $albums = $instagram->getCarouselAlbums(2);
	 * // Get albums from a specified user
	 * $albums = $instagram->getCarouselAlbums("username"); // 4 returned if found
	 * // Get 3 albums from a specified user
	 * $albums = $instagram->getCarouselAlbums("username", 3);
	 * // Render the albums
	 * if($albums->count()) {
	 *     echo "<ul>" . $instagram->getCarouselAlbums()->each(function($album) {
	 *         $tpl = "<li><a href='{href}'><img src='{src}' alt='{alt}'></a></li>"
	 *         return "<li><ul>" . $album->children->each($tpl) . "</ul></li>";
	 *     }) . "</ul>";
	 * }
	 * 
	 * ~~~
	 * 
	 * #pw-group-media
	 *
	 * @param string $username The username of the authorized Instagram user.
	 * @param int $count The number of items to return (default=4).
	 * @return WireArray
	 * @see InstagramBasicDisplayApi::getMedia()
	 *
	 */
	public function getCarouselAlbums($username = null, $count = 4) {
		if(!$count) $count = $this->imageCount;
		return $this->getMediaByType(self::mediaTypes["carouselAlbum"], $username, $count);
	}

	/**
	 * Get the default user
	 * 
	 * ~~~
	 * // Output a link to the default user's Instagram profile
	 * $username = $instagram->getDefaultUser();
	 * if($username) echo "<a href='https://www.instagram.com/$username' target='_blank'>Instagram Profile</a>";
	 * ~~~
	 * 
	 * #pw-group-profile
	 *
	 * @return string
	 *
	 */
	public function getDefaultUser() {
		$data = $this->getAccessData();
		if(!count($data)) return "";
		if(function_exists("array_key_first")) {
			$username = array_key_first($data); // PHP 7.3
		} else {
			foreach($data as $username => $data) break;
		}
		return $username;
	}

	/**
	 * Get a list of Images for a user
	 * 
	 * ~~~
	 * // Get images from the default user
	 * $images = $instagram->getImages(); // Returns all images found in the first request
	 * // Get 10 images from the default user
	 * $images = $instagram->getImages(10);
	 * // Get images from a specified user
	 * $images = $instagram->getImages("username"); // Returns all images found in the first request
	 * // Get 8 images from a specified user
	 * $images = $instagram->getImages("username", 8);
	 * // Render the images
	 * echo "<ul>" . $images->each("<li><a href='{href}'><img src='{src}' alt='{alt}'></a></li>") . "</ul>";
	 * ~~~
	 * 
	 * #pw-group-media
	 *
	 * @param string $username The username of the authorized Instagram user.
	 * @param int $count The number of items to return.
	 * @return WireArray
	 * @see InstagramBasicDisplayApi::getMedia()
	 *
	 */
	public function getImages($username = null, $count = 0) {
		return $this->getMediaByType(self::mediaTypes["image"], $username, $count);
	}

	/**
	 * Get a list of Media for a user
	 * 
	 * This method is called by a number of others such as `getImages()`. 
	 * Where possible, please use these abstractions instead of calling this method directly.
	 *
	 * https://developers.facebook.com/docs/instagram-basic-display-api/guides/getting-profiles-and-media
	 * 
	 * ~~~
	 * // Get media from the default user
	 * $items = $instagram->getMedia(); // Returns all media found in the first request
	 * // Get media from a specified user
	 * $items = $instagram->getMedia("username"); // Returns all media found in the first request
	 * // Get 10 media items from the default user
	 * $items = $instagram->getMedia(10);
	 * // Get 10 images from a specified user
	 * $items = $instagram->getMedia(10, "image");
	 * // Get the most recent image from the default user with a specified tag
	 * $items = $instagram->getMedia(1, ["type" => "image", "tag" => "tag"]);
	 * if($items->count()) $image = $items->first;
	 * ~~~
	 * 
	 * #pw-group-media
	 *
	 * @param string $username The username of the authorized Instagram user.
	 * @param array $options Options to modify default behaviour:
	 * - `asArray` (bool): Should the data be returned as an array? (default=false)
	 * - `count` (int): The number of items to return (default=0).
	 * - `tag` (string): An optional tag to filter by (default="").
	 * - `type` (string): The type of media to return (default="").
	 * @return WireArray|array
	 *
	 */
	public function getMedia($username = null, $options = []) {

		// Get default options
		$options = $this->getMediaOptions($username, $options);

		// Make sure the type is valid
		if($options["type"]) {
			$options["type"] = strtoupper($options["type"]);
			if(!in_array($options["type"], self::mediaTypes)) {
				$options["type"] = "";
			}
		}

		// Remove leading hashtag from a given tag
		if($options["tag"]) $options["tag"] = ltrim($options["tag"], "#");

		// Make sure this is a valid username
		if(isset($username)) {
			if(is_string($username)) {
				if(!$this->isValidUser($username)) {
					return [];
				}
			} else {
				$username = null;
			}
		}

		$request = [
			"fields" => implode(",", [
				"caption", // The Media's caption text. Not returnable for Media in albums.
				"id", // The Media's ID.
				"media_type", // The Media's type. Can be IMAGE, VIDEO, or CAROUSEL_ALBUM.
				"media_url", // The Media's URL.
				"permalink", // The Media's permanent URL.
				"thumbnail_url", // The Media's thumbnail image URL. Only available on VIDEO Media.
				"timestamp", // The Media's publish date in ISO 8601 format.
				"username", // The Media owner's username.
			]),
			"access_token" => $this->getAccessToken($username),
		];

		$data = $this->wire("cache")->getFor(
			$this,
			$this->getCacheKey([__FUNCTION__, $username], array_merge($options, ["asArray" => true])), 
			function() use ($username, $options, $request) {

				$response = $this->apiRequest("me/media", $request);
		
				$data = [];
				if(is_array($response)) {
		
					if($this->hasMedia($response)) {
		
						$items = $this->filterMedia($response["data"], $options);
						$itemCount = count($items);
						$totalCount = $options["imageCount"] ?: $options["count"];
		
						if(((!$totalCount && !$itemCount) || ($totalCount && $totalCount > $itemCount)) && isset($response["paging"]["next"])) {
		
							$next = $response["paging"]["next"];
							do {
		
								$response = $this->apiRequest($next);
		
								if($this->hasMedia($response) && isset($response["paging"]["next"])) {
									$items = array_merge($items, $this->filterMedia($response["data"], $options));
									$itemCount = count($items);
									$next = $response["paging"]["next"];
								} else {
									$itemCount = $totalCount;
								}
		
							} while($itemCount < $totalCount);
						}
		
						$count = $totalCount && $totalCount <= $itemCount ? $totalCount : $itemCount;
						for($i = 0; $i < $count; $i++) {
							$data[] = $items[$i];
						}
		
					} else {
		
						$this->logError($this->_("Could not process user media"), $response);
					}
		
				} else {
		
					$this->logError(
						$this->_("Could not get user media"),
						["username" => $username, "options" => $options]
					);
				}

				return $data;
			},
			$this->getCacheTime()
		);

		if(!$options["asArray"] && is_array($data)) {

			// Convert to WireArray/WireData
			$items = $data;
			$data = new WireArray();
			foreach($items as $item) {

				$media = $this->getMediaItem($item);
		
				// Get Carousel Album children
				if($media->type == self::mediaTypes["carouselAlbum"]) {
					$request["fields"] = str_replace("caption,", "", $request["fields"]);
					$response = $this->apiRequest("$item[id]/children", $request);
					if($this->hasMedia($response)) {
						$children = new WireArray();
						foreach($response["data"] as $child) {
							$children->add($this->getMediaItem($child));
						}
						$media->set("children", $children);
					}
				}

				$data->add($media);
			}
		}

		return $data;
	}

	/**
	 * Get a user's profile information
	 *
	 * https://developers.facebook.com/docs/instagram-basic-display-api/reference/user
	 * 
	 * ~~~
	 * // Get the profile data of the default user
	 * $profile = $instagram->getProfile();
	 * // Get the profile data of a specified user
	 * $profile = $instagram->getProfile("username");
	 * // Display the profile information
	 * if(count($profile)) {
	 *     $info = "";
	 *     foreach($profile as $key => $value) {
	 *         $info .= "<li>$key: $value</li>";
	 *     }
	 *     echo "<ul>$info</ul>";
	 * }
	 * // Fields returned: username, id, account_type, media_count;
	 * ~~~
	 * 
	 * #pw-group-profile
	 *
	 * @param string $username The username of the authorized Instagram user.
	 * @param string $accessToken The access token of the authorized Instagram user.
	 * @return array
	 *
	 */
	public function getProfile($username = null, $accessToken = null) {
		if(isset($username) && is_null($accessToken) && !$this->isValidUser($username)) {
			return [];
		}
		return $this->processApiResponse(
			$this->apiRequest("me", [
				"fields" => implode(",", [
					"username", // The User's username.
					"id", // The User's ID.
					"account_type", // The User's account type. Can be BUSINESS, MEDIA_CREATOR, or PERSONAL.
					"media_count", // The number of Media on the User. This field requires the instagram_graph_user_media permission.
				]),
				"access_token" => (isset($accessToken) ? $accessToken : $this->getAccessToken($username)),
			]),
			false
		) ?: [];
	}

	/**
	 * Get recent comments
	 *
	 * Returns a blank array as comments cannot be accessed by this API.
	 *
	 * #pw-group-instagram-feed
	 *
	 * @param array $media Unused. Provided for compatibility with InstagramFeed.
	 * @return array An empty array
	 * @see InstagramFeed::getRecentComments()
	 *
	 */
	public function getRecentComments($media = null) {
		$this->logError($this->_("Sorry, comments are not accessible using this API."));
		return [];
	}

	/**
	 * Get the most recent media published by a user
	 * 
	 * This is probably the most commonly used method from 
	 * [InstagramFeed](https://modules.processwire.com/modules/instagram-feed/).
	 * You should not need to change your method call, however some of
	 * the values returned by the deprecated API are no longer present and
	 * are returned as `null` instead.
	 * 
	 * ~~~
	 * // $instagram = $modules->get("InstagramFeed");
	 * $instagram = $modules->get("InstagramBasicDisplayApi");
	 * $images = $instagram->setImageCount(6)->getRecentMedia();
	 * ~~~
	 *
	 * #pw-group-instagram-feed
	 *
	 * @param string $username The username of the authorized Instagram user.
	 * @param array $options Options to modify behaviour:
	 * - `getSize` (bool): Should the image width and height be returned?
	 * This is set to `false` by default as it slows response time.
	 * - `tag` (string): An optional tag to filter by (default="").
	 * @return array
	 * @see InstagramFeed::getRecentMedia()
	 *
	 */
	public function getRecentMedia($username = null, $options = []) {

		// Shortcuts
		if(isset($username) && !is_string($username)) {
			if(is_bool($username)) $options = ["getSize" => $username];
			if(is_array($username)) $options = $username;
			$username = null;
		}
		if(is_bool($options)) $options = ["getSize" => $options];
		if(is_string($options)) $options = ["tag" => $options];

		// Set default options
		$options = array_merge([
			"getSize" => false,
			"tag" => "",
		], $options);

		return $this->wire("cache")->getFor(
			$this,
			$this->getCacheKey([__FUNCTION__, $username, $this->imageCount], $options),
			function() use ($username, $options) {
				
				$items = $this->getMedia($username, [
					"asArray" => true,
					"count" => 0,
					"imageCount" => $this->imageCount,
					"type" => self::mediaTypes["image"],
					"tag" => $options["tag"],
				]);

				$data = [];
				if(is_array($items)) {

					$count = count($items);
					$count = $this->imageCount && $this->imageCount <= $count ? $this->imageCount : $count;
					$i = 0;
					foreach($items as $item) {

						if($i >= $count) break;

						$user = [
							"id" => null,
							"full_name" => null,
							"profile_picture" => null,
							"username" => $item["username"],
						];

						$image = [
							"url" => $item["media_url"],
							"width" => null,
							"height" => null,
						];

						if($options["getSize"]) {
							$size = getimagesize($image["url"]);
							$image = array_merge($image, [
								"width" => $size[0],
								"height" => $size[1]
							]);
						}

						$timestamp = strtotime($item["timestamp"]);

						$data[] = [
							"id" => $item["id"],
							"user" => $user,
							"images" => [
								"thumbnail" => $image,
								"low_resolution" => $image,
								"standard_resolution" => $image,
							],
							"created_time" => $timestamp,
							"caption" => [
								"id" => null,
								"text" => $item["caption"],
								"created_time" => $timestamp,
								"from" => $user,
							],
							"user_has_liked" => null,
							"likes" => ["count" => null],
							"tags" => $item["tags"],
							"filter" => null,
							"comments" => ["count" => null],
							"type" => strtolower($item["media_type"]),
							"link" => $item["permalink"],
							"location" => [
								"latitude" => null,
								"longitude" => null,
								"name" => null,
								"id" => null,
							],
							"attribution" => null,
							"users_in_photo" => null,
						];

						$i++;
					}
				}

				return $data;
			},
			$this->getCacheTime()
		);
	}

	/**
	 * Get a list of recently tagged media
	 * 
	 * Instagram Basic Display API does not provide a way to search media by tag.
	 * This implementation will keep calling the API until it has enough matching items
	 * to return, or all media items have been retrieved.
	 * 
	 * Using this method is therefore **not recommended** as it is likely to slow 
	 * response times and could possibly exhaust resource limits.
	 *
	 * #pw-group-instagram-feed
	 *
	 * @param string $tag The tag to search for.
	 * @param string $username The username of the authorized Instagram user.
	 * @param array $options Options to modify behaviour.
	 * @return array
	 * @see InstagramFeed::getRecentMediaByTag()
	 * @see InstagramBasicDisplayApi::getRecentMedia()
	 *
	 */
	public function getRecentMediaByTag($tag, $username = null, $options = []) {
		$options = $this->getMediaOptions($username, $options);
		$options["tag"] = $tag;
		return $this->getRecentMedia($username, $options);
	}

	/**
	 * Get the Redirect URI
	 * 
	 * #pw-group-authentication
	 *
	 * @param bool $httpUrl Should the full URI with protocol be returned? (default=true)
	 * @return string
	 *
	 */
	public function getRedirectUri($httpUrl = true) {
		$config = $this->wire("config");
		return ($httpUrl ? rtrim(($config->https ? "https" : "http") . "://" . $config->httpHost, "/") : "") .
		$config->urls->admin . $this->className;
	}

	/**
	 * Get the user's ID from their username
	 *
	 * #pw-group-instagram-feed
	 *
	 * @param string $username The username of the authorized Instagram user.
	 * @return int
	 * @see InstagramFeed::getUserIdByUsername()
	 *
	 */
	public function getUserIdByUsername($username = "") {
		$data = $this->getAccessData($username);
		return isset($data["user_id"]) ? (int) $data["user_id"] : 0;
	}

	/**
	 * Get the most recent Video for a user
	 * 
	 * ~~~
	 * // Get the most recent video from the default user
	 * $video = $instagram->getVideo();
	 * // Get the most recent video from a specified user
	 * $video = $instagram->getVideo("username");
	 * // Render the video
	 * if(isset($video)) {
	 *     echo "<video src='$video->src' poster='$video->poster' type='video/mp4' controls playsinline></video>" . 
	 *         ($video->description ? "<p>$video->description</p>" : "");
	 * }
	 * ~~~
	 * 
	 * #pw-group-media
	 *
	 * @param string $username The username of the authorized Instagram user.
	 * @return WireData|null
	 * @see InstagramBasicDisplayApi::getMedia()
	 *
	 */
	public function getVideo($username = null) {
		$video = $this->getVideos($username, 1);
		return $video->count() ? $video->first : null;
	}

	/**
	 * Get a list of Videos for a user
	 * 
	 * ~~~
	 * // Get videos from the default user 
	 * $videos = $instagram->getVideos(); // 4 returned if found
	 * // Get 2 videos from the default user
	 * $videos = $instagram->getVideos(2);
	 * // Get videos from a specified user
	 * $videos = $instagram->getVideos("username"); // 4 returned if found
	 * // Get 3 videos from a specified user
	 * $videos = $instagram->getVideos("username", 3);
	 * // Render the videos
	 * if($videos->count()) {
	 *     $tpl = "<li><video src='{src}' poster='{poster}' type='video/mp4' controls playsinline></video></li>";
	 *     echo "<ul>" . $videos->each($tpl) . "</ul>";
	 * }
	 * ~~~
	 * 
	 * #pw-group-media
	 *
	 * @param string $username The username of the authorized Instagram user.
	 * @param int $count The number of items to return (default=4).
	 * @return WireArray
	 * @see InstagramBasicDisplayApi::getMedia()
	 *
	 */
	public function getVideos($username = null, $count = 4) {
		if(!$count) $count = $this->imageCount;
		return $this->getMediaByType(self::mediaTypes["video"], $username, $count);
	}

	/**
	 * Set the image count
	 *
	 * #pw-group-instagram-feed
	 *
	 * @param int $imageCount
	 * @return $this
	 *
	 */
	public function setImageCount($imageCount = 4) {
		$this->imageCount = (int) $imageCount;
		return $this;
	}

	/**
	 * API Request
	 *
	 * #pw-internal
	 *
	 * @param string $endpoint
	 * @param array $data
	 * @param bool $useCache
	 * @return array|false
	 *
	 */
	protected function apiRequest($endpoint, array $data = [], $useCache = true) {
		
		$http = new WireHttp();

		// If the long-lived token expires in the next week then refresh it
		if($useCache && count($data) && isset($data["access_token"])) {
			foreach($this->getAccessData() as $username => $accessData) {
				if(isset($data["access_token"]) && $data["access_token"] == $accessData["access_token"]) {
					if(isset($accessData["expires_in"]) && (($accessData["expires_in"] - (86400 * 7)) < time())) {
						$this->refreshAccessToken($username, $accessData["access_token"]);
						break;
					}
				}
			}
		}

		if($useCache) {

			$cacheData = $data;
			if(count($cacheData) && isset($cacheData["client_secret"])) {
				unset($cacheData["client_secret"]);
			}

			$response = $this->wire("cache")->getFor(
				$this,
				$this->getCacheKey([$endpoint], $cacheData),
				function() use ($http, $endpoint, $data) {
					return $http->getJSON($this->getEndpoint($endpoint), true, $data);
				},
				($this->cacheTime ?: 3600)
			);

		} else {

			$response = $http->getJSON($this->getEndpoint($endpoint), true, $data);
		}

		if($response === false) {
			$args = ["endpoint" => $endpoint, "data" => $data, "useCache" => $useCache];
			if(isset($data["client_secret"])) {
				// Obfuscate secret
				$args["data"]["client_secret"] = $this->obfuscateSecret($data["client_secret"]);
			}
			// Log error
			$this->logError($this->_("API Request Failed"), $args);
		}

		return $response;
	}

	/**
	 * Filter a media response
	 *
	 * #pw-internal
	 *
	 * @param array $media
	 * @param array $options
	 * @return array
	 *
	 */
	protected function filterMedia(array $media, array $options = []) {

		$options = array_merge(["type" => "", "tag" => ""], $options);
		$typeImage = self::mediaTypes["image"];
		
		// Set tags and type
		$items = [];
		foreach($media as $item) {

			// Get tags from caption
			preg_match_all('/(#\w+)/', $item["caption"], $matches);
			$item["tags"] = [];
			if(is_array($matches) && count($matches)) {
				foreach($matches[0] as $tag) {
					$item["tags"][] = strtolower(ltrim($tag, "#"));
				}
			}
			// If the IMAGE type is specified, set CAROUSEL_ALBUM to IMAGE for added items
			if($options["type"] == $typeImage && $item["media_type"] == self::mediaTypes["carouselAlbum"]) {
				$item["media_type"] = $typeImage;
			}

			$items[] = $item;
		}

		// Filter by type
		if($options["type"]) {
			$media = $items;
			$items = [];
			foreach($media as $item) {
				if($item["media_type"] == $options["type"]) {
					$items[] = $item;
				}
			}
		}

		// Filter by tag
		if($options["tag"]) {
			$media = $items;
			$items = [];
			foreach($media as $item) {
				if(in_array(strtolower($options["tag"]), $item["tags"])) {
					$items[] = $item;
				}
			}
		}

		return $items;
	}

	/**
	 * Get access data
	 *
	 * #pw-internal
	 *
	 * @param string $username
	 * @return array
	 *
	 */
	protected function getAccessData($username = null) {
		if(isset($username) && empty($username)) $username = $this->getDefaultUser();
		$data = $this->accessData ? json_decode($this->accessData, 1) : [];
		return isset($username) ? (count($data) && array_key_exists($username, $data) ? $data[$username] : []) : $data;
	}

	/**
	 * Get the user's access token
	 *
	 * #pw-internal
	 *
	 * @param string $username
	 * @return string
	 *
	 */
	protected function getAccessToken($username = null) {
		if(empty($this->accessData)) return "";
		if(is_null($username)) $username = "";
		$data = $this->getAccessData($username);
		return isset($data["access_token"]) ? $data["access_token"] : "";
	}

	/**
	 * Get the cache key for this request
	 *
	 * #pw-internal
	 *
	 * @param array $keys
	 * @param array $options
	 * @return string
	 *
	 */
	protected function getCacheKey(array $keys, array $data = []) {
		if(count($data)) $keys[] = json_encode($data);
		return $this->wire("sanitizer")->text(base64_encode(implode("||", $keys)));
	}

	/**
	 * Get the cache time
	 *
	 * #pw-internal
	 *
	 * @param int $cacheTime
	 * @return int
	 *
	 */
	protected function getCacheTime($cacheTime = 0) {
		return $cacheTime ?: ($this->cacheTime ?: 3600);
	}

	/**
	 * Get the API endpoint
	 *
	 * #pw-internal
	 *
	 * @param string $endpoint
	 * @return string
	 *
	 */
	protected function getEndpoint($endpoint) {
		if(strpos($endpoint, "://") === false) {
			$endpoint = self::urlGraph . $endpoint;
		}
		return $endpoint;
	}

	/**
	 * Get media items by type
	 *
	 * @param string $type
	 * @param string $username
	 * @param int
	 * @return WireArray|array
	 * @see InstagramBasicDisplayApi::getMedia()
	 *
	 */
	protected function getMediaByType($type, $username = null, $count = 0) {
		if(is_int($username)) {
			$count = $username;
			$username = null;
		}
		return $this->getMedia($username, [
			"count" => $count,
			"type" => $type,
		]);
	}

	/**
	 * Get media item
	 *
	 * @param array $item
	 * @return WireArray
	 *
	 */
	protected function getMediaItem($item) {

		$media = new WireData();
		foreach([
			"id" => ["id"],
			"media_type" => ["type"],
			"caption" => ["alt", "description"],
			"media_url" => ["src", "url"],
			"tags" => ["tags"],
			"timestamp" => ["created", "createdStr"],
			"permalink" => ["href", "link"],
			"thumbnail_url" => ["poster"],
		] as $key => $properties) {
			if(isset($item[$key])) {
				foreach($properties as $property) {
					$value = $item[$key];
					switch($key) {
						case "caption":
							$value = $this->wire("sanitizer")->entities1($value, true);
							break;
						case "timestamp":
							if($property == "created") {
								$value = strtotime($value);
							}
							break;
					}
					$media->set($property, $value);
				}
			}
		}
		return $media;
	}

	/**
	 * Get the default getMedia options
	 *
	 * @param mixed $username
	 * @param mixed $options
	 * @return array
	 * @see InstagramBasicDisplayApi::getMedia()
	 *
	 */
	protected function getMediaOptions($username, $options) {

		// Shortcuts
		if(is_array($username)) $options = $username;
		if(is_string($options)) $options = ["type" => $options];
		if(is_bool($options)) $options = ["asArray" => $options];
		if(is_int($options)) $options = ["count" => $options];

		// Set default options
		$options = array_merge([
			"asArray" => false,
			"count" => 0,
			"imageCount" => 0,
			"type" => "",
			"tag" => "",
		], $options);

		if(!is_string($username)) {
			if(is_int($username)) $options["count"] = $username;
			if(is_bool($username)) $options["asArray"] = $username;
		}
		
		return $options;
	}

	/**
	 * Return an optional value indicating a server-specific state
	 *
	 * #pw-internal
	 *
	 * @return string
	 *
	 */
	protected function getState() {
		$n = strlen((string) $this->wire("config")->installed);
		return substr(base64_encode($this->wire("config")->userAuthSalt), round($n / 2), $n);
	}

	/**
	 * Does the response have media?
	 *
	 * #pw-internal
	 *
	 * @param array $response
	 * @return bool
	 *
	 */
	protected function hasMedia($response) {
		return is_array($response) ? isset($response["data"]) && is_array($response["data"]) && count($response["data"]) : false;
	}

	/**
	 * Is the given username a valid authorized user?
	 *
	 * #pw-internal
	 *
	 * @param string $username
	 * @return bool
	 *
	 */
	protected function isValidUser($username) {
		$valid = array_key_exists($username, $this->getAccessData());
		if(!$valid) $this->logError(sprintf($this->_("%s is not an authorized user."), "`$username`"));
		return $valid;
	}

	/**
	 * Log an error message
	 *
	 * #pw-internal
	 *
	 * @param string $message
	 * @param array $data
	 * @return bool
	 *
	 */
	protected function logError($message, array $data = []) {
		if(count($data)) $message .= ": " . json_encode($data);
		return $this->log($message);
	}

	/**
	 * Refresh a long-lived Instagram User Access Token
	 *
	 * https://developers.facebook.com/docs/instagram-basic-display-api/reference/refresh_access_token
	 *
	 * #pw-internal
	 *
	 * @param string $username
	 * @param string $accessToken
	 * @return array|false
	 *
	 */
	protected function refreshAccessToken($username, $accessToken) {
		$response = $this->processApiResponse(
			$this->apiRequest("refresh_access_token", [
				"grant_type" => "ig_refresh_token",
				"access_token" => $accessToken,
			], false),
			$this->_("Could not refresh long-lived access token")
		);
		if(is_array($response)) {
			$this->saveAccessData($username, $response);
			$this->log(sprintf($this->_("Long-lived access token refreshed for %s"), $username));
		}
		return $response;
	}

	/**
	 * Exchange a short-lived Instagram User Access Token for long-lived Instagram User Access Token
	 *
	 * https://developers.facebook.com/docs/instagram-basic-display-api/reference/access_token
	 *
	 * #pw-internal
	 *
	 * @param string $oAuthAccessToken The valid (unexpired) short-lived Instagram User Access Token that you want to exchange for a long-lived token.
	 * @return array|false
	 *
	 */
	protected function requestAccessToken($oAuthAccessToken) {
		return $this->processApiResponse(
			$this->apiRequest("access_token", [
				"grant_type" => "ig_exchange_token",
				"client_secret" => $this->clientSecret,
				"access_token" => $oAuthAccessToken,
			], false),
			$this->_("Could not exchange token for long-lived token")
		);
	}

	/**
	 * Exchange an Authorization Code for a short-lived Instagram User Access Token
	 *
	 * https://developers.facebook.com/docs/instagram-basic-display-api/reference/oauth-access-token
	 *
	 * #pw-internal
	 *
	 * @param string $code The Authorization Code you want to exchange for an Instagram User Access Token.
	 * @return array|false
	 *
	 */
	protected function requestOAuthAccessToken($code) {

		$args = [
			"endpoint" => "oauth/access_token",
			"data" => [
				"client_id" => $this->clientId,
				"client_secret" => $this->clientSecret,
				"grant_type" => "authorization_code",
				"redirect_uri" => $this->getRedirectUri(),
				"code" => $code,
			],
		];
		$http = new WireHttp();
		$response = $http->post(self::urlAccess . $args["endpoint"], $args["data"]);

		if($response === false) {
			// Obfuscate secret
			$args["data"]["client_secret"] = $this->obfuscateSecret($args["data"]["client_secret"]);
			// Log error
			$this->logError($this->_("API Request Failed"), $args);
		}

		return $this->processApiResponse($response, [
			"check" => ["user_id", "access_token"],
			"set" => ["oauth_access_token" => "access_token"],
			"error" => $this->_("Could not exchange code for token"),
		]);
	}

	/**
	 * Save access data
	 *
	 * #pw-internal
	 *
	 * @param string $username
	 * @param array $data
	 * @return bool
	 *
	 */
	protected function saveAccessData($username, $data = []) {
		$tokens = $this->getAccessData();
		if(isset($tokens[$username])) {
			$data = array_merge($tokens[$username], $data);
		}
		$tokens[$username] = $data;
		$modules = $this->wire("modules");
		$json = json_encode($tokens);
		if(method_exists($modules, "saveConfig")) {
			return $modules->saveConfig($this, "accessData", $json);
		} else {
			$data = $modules->getModuleConfigData($this);
			$data["accessData"] = $json;
			return $modules->saveModuleConfigData($this, $data);
		}
	}

	/**
	 * Obfuscate the client secret
	 *
	 * #pw-internal
	 *
	 * @param string $secret
	 * @return string
	 *
	 */
	private function obfuscateSecret($secret) {
		return substr($secret, 0, 3) .
			str_repeat("*", strlen($secret) - 6) .
			substr($secret, -3);
	}

	/**
	 * Process a response from an API request
	 *
	 * #pw-internal
	 *
	 * @param mixed $response
	 * @param array $options
	 * @return array|false
	 *
	 */
	private function processApiResponse($response, $options = []) {

		// Shortcuts
		if(!is_array($options)) {
			$options = is_bool($options) ?
				["check" => $options, "set" => $options] :
				["error" => $options];
		}

		// Set default options
		$options = array_merge([
			"check" => ["access_token", "token_type", "expires_in"],
			"error" => $this->_("Error"),
			"set" => ["expires_in" => time()],
		], $options);

		$data = is_array($response) ? $response : json_decode($response, 1);
		if(is_array($data)) {

			// Check that the response is successful
			$success = true;
			if(is_array($options["check"])) {
				foreach($options["check"] as $key) {
					if(!isset($data[$key])) $success = false;
				}
			}

			if($success) {

				// Set any additional values
				if(is_array($options["set"])) {
					foreach($options["set"] as $key => $value) {
						if(isset($data[$value])) {
							$data[$key] = $data[$value];
						} else if(is_int($value)) {
							$data[$key] = $data[$key] + $value;
						}
					}
				}

				// If the request is successful, return the response
				return $data;

			} else {

				// If not, log the response
				$this->logError($options["error"], $data);
			}
		}

		return false;
	}

	/**
	 * Process a response
	 *
	 * #pw-internal
	 *
	 */
	private function processResponse() {

		$input = $this->wire("input");
		$session = $this->wire("session");

		if($input->get->pageName("error")) {

			// Cancelled Authorization
			// https://developers.facebook.com/docs/instagram-basic-display-api/reference/oauth-authorize#canceled-authorization

			$reason = $input->get->pageName("error_reason");
			$description = $input->get->text("error_description");
			$message = $this->_("Could not authorize user");

			// Log
			$this->logError($message, [
				"reason" => $reason,
				"description" => $description,
			]);

			// Set error message and redirect to the admin homepage
			$session->error(sprintf($this->_('%1$s: %2$s'), $message, $description));
			$session->redirect($this->wire("config")->urls->admin);

		} else {

			// Check that the state is correct
			$state = $this->getState();
			$stateRequest = $input->get->text("state");
			if($stateRequest == $state) {

				// Get the auth code
				$code = $input->get->text("code");
				if($code) {

					// Get the token
					$oAuth = $this->requestOAuthAccessToken($code);
					if($oAuth) {

						// Get the long-lived token
						$data = $oAuth;
						$access = $this->requestAccessToken($oAuth["access_token"]);
						if($access) {

							$data = array_merge($data, $access);
							$profile = $this->getProfile($oAuth["user_id"], $oAuth["access_token"]);
							$username = $profile && isset($profile["username"]) ? $profile["username"] : false;

							if($username) {
								if($this->saveAccessData($username, $data)) {
									$session->message(sprintf($this->_('%1$s: The Instagram user %2$s has been successfully authenticated.'), $this->className, $username));
									$session->redirect($this->wire("config")->urls->admin);
								}
							}

						}
					}

				} else {
					$this->logError($this->_("No code returned"), $_GET);
				}

			} else {
				$this->logError("Invalid state", [$state, $stateRequest]);
			}
		}
	}
}
